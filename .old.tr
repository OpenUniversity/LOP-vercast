
    application initialState should properly create an initial state: [2K[0G  â€¤ application initialState should properly create an initial state
    application apply should return the query result based on the state: [2K[0G  â€¤ application apply should return the query result based on the state
    application apply should apply the patch to the state: [2K[0G  â€¤ application apply should apply the patch to the state
    application inv should invert patches: [2K[0G  â€¤ application inv should invert patches
    counter get should initially return 0: [2K[0G  â€¤ counter get should initially return 0
    counter add should increase the counter value by the given amount: [2K[0G  â€¤ counter add should increase the counter value by the given amount
    counter add should be reversible: [2K[0G  â€¤ counter add should be reversible
    DummyBranch as Branch checkedUpdate should update the branch state if given that the state condition is met: [2K[0G  â€¤ DummyBranch as Branch checkedUpdate should update the branch state if given that the state condition is met
    DummyBranch as Branch checkedUpdate should return the tip state before modification: [2K[0G  â€¤ DummyBranch as Branch checkedUpdate should return the tip state before modification
    DummyBranch as Branch checkedUpdate should not update the branch state if the first argument does not match the current tip value: [2K[0G  â€¤ DummyBranch as Branch checkedUpdate should not update the branch state if the first argument does not match the current tip value
    DummyVersionGraph as VersionGraph addEdge should accept an edge and add it to the graph: [2K[0G  â€¤ DummyVersionGraph as VersionGraph addEdge should accept an edge and add it to the graph
    DummyVersionGraph as VersionGraph addEdge should create a dual mapping, mapping also the destination to the source: [2K[0G  â€¤ DummyVersionGraph as VersionGraph addEdge should create a dual mapping, mapping also the destination to the source
    DummyVersionGraph as VersionGraph findCommonAncestor should find the common ancestor of two nodes, and the path to each of them: [2K[0G  â€¤ DummyVersionGraph as VersionGraph findCommonAncestor should find the common ancestor of two nodes, and the path to each of them
    hash should give any two different JSONable objects a different hash code: [2K[0G  â€¤ hash should give any two different JSONable objects a different hash code
    hash should reconstruct an object from the hash that is identical to the origianl object: [2K[0G  â€¤ hash should reconstruct an object from the hash that is identical to the origianl object
    hash should store its own copy of the object: [2K[0G  â€¤ hash should store its own copy of the object
    HashedApp initialState should return the initial state's hash: [2K[0G  â€¤ HashedApp initialState should return the initial state's hash
    HashedApp apply should calculate the hash of the new state, the computation result and the safety flag, based on an original state and a patch: [2K[0G  â€¤ HashedApp apply should calculate the hash of the new state, the computation result and the safety flag, based on an original state and a patch
    HashedApp apply _inv should handle _inv patches: [2K[0G  â€¤ HashedApp apply _inv should handle _inv patches
    HashedApp apply _inv should support _inv of _inv patches: [2K[0G  â€¤ HashedApp apply _inv should support _inv of _inv patches
    HashedApp apply _comp should handle _comp patches: [2K[0G  â€¤ HashedApp apply _comp should handle _comp patches
    HashedApp apply _comp should support _inv of _comp patches: [2K[0G  â€¤ HashedApp apply _comp should support _inv of _comp patches
    HashedApp apply _comp should replace the output from patches that were not safely applied with an object containing a $badPatch field, containing the patch: [2K[0G  â€¤ HashedApp apply _comp should replace the output from patches that were not safely applied with an object containing a $badPatch field, containing the patch
    HashedApp apply _comp should support a "weak" flag, which when exists and true, avoids execution of unsafe sub-patches: [2K[0G  â€¤ HashedApp apply _comp should support a "weak" flag, which when exists and true, avoids execution of unsafe sub-patches
    HashedApp apply _hashed should handle _hashed patches: [2K[0G  â€¤ HashedApp apply _hashed should handle _hashed patches
    HashedApp apply _hashed should support _inv of _hashed: [2K[0G  â€¤ HashedApp apply _hashed should support _inv of _hashed
    HashedApp trans should return the hash of the target state when given a source state and a patch: [2K[0G  â€¤ HashedApp trans should return the hash of the target state when given a source state and a patch
    HashedApp trans should cache previous calls and only invoke the actual method if the combination of input state and patch have not yet been encountered: [2K[0G  â€¤ HashedApp trans should cache previous calls and only invoke the actual method if the combination of input state and patch have not yet been encountered
    HashedApp trans should avoid hashing _hashed patches, and should used the undelying hash instead: [2K[0G  â€¤ HashedApp trans should avoid hashing _hashed patches, and should used the undelying hash instead
    HashedApp query should return the result of applying a patch: [2K[0G  â€¤ HashedApp query should return the result of applying a patch
    HashedApp query should fail when given a patch that modifies the state: [2K[0G  â€¤ HashedApp query should fail when given a patch that modifies the state
    HashedApp branchQuery should perform a query on the tip of the given branch: [2K[0G  â€¤ HashedApp branchQuery should perform a query on the tip of the given branch
    HashedApp branchTrans should perform a transition, updating the tip of the branch: [2K[0G  â€¤ HashedApp branchTrans should perform a transition, updating the tip of the branch
    VCObj createObject(cls, s0, cb(err, h0)) should create an object state hash for the given class and initial state: [2K[0G  â€¤ VCObj createObject(cls, s0, cb(err, h0)) should create an object state hash for the given class and initial state
    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should apply a patch to the given state, activating a class method: [2K[0G  â€¤ VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should apply a patch to the given state, activating a class method
    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should emit the new state hash, the result, effect and conflict flag emitted by the invoked method: [2K[0G  â€¤ VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should emit the new state hash, the result, effect and conflict flag emitted by the invoked method
    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should pass the invoked method the state as its this parameter: [2K[0G  â€¤ VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should pass the invoked method the state as its this parameter
    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should emit the new state based on the content of "this" when the method returns: [2K[0G  â€¤ VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should emit the new state based on the content of "this" when the method returns
    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should allow objects to further call other objects by sending them patches: [2K[0G  â€¤ VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should allow objects to further call other objects by sending them patches

  39 passing (440 ms)

