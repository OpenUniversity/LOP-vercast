
    AsyncObjectStore .init(className, args, cb(err, v0)) should initialize an object of class className with arguments args and return the ID
  ․ AsyncObjectStore .init(className, args, cb(err, v0)) should initialize an object of class className with arguments args and return the ID
    AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should apply patch p to v1, to receive v2
  ․ AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should apply patch p to v1, to receive v2
    AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return the result r of the patch
  ․ AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return the result r of the patch
    AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return the result version even if the source version is not in the cache
  ․ AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return the result version even if the source version is not in the cache
    AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return the result r even if the source version is not in the cache
  ․ AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return the result r even if the source version is not in the cache
    AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return the conflict flag (in cache)
  ․ AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return the conflict flag (in cache)
    AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return the conflict flag (out of cache)
  ․ AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return the conflict flag (out of cache)
    AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return all effect patches (in cache)
  ․ AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return all effect patches (in cache)
    AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return all effect patches (out of cache)
  ․ AsyncObjectStore .transRaw(v1, p, cb(err, v2, r, conf, eff)) should return all effect patches (out of cache)
    AsyncObjectStore .trans(v1, ps, cb(err, v2, r, conf, w)) should perform transitions and return the result version and result
  ․ AsyncObjectStore .trans(v1, ps, cb(err, v2, r, conf, w)) should perform transitions and return the result version and result
    AsyncObjectStore .trans(v1, ps, cb(err, v2, r, conf, w)) should perform a sequence of transitions, returning the result of each
  ․ AsyncObjectStore .trans(v1, ps, cb(err, v2, r, conf, w)) should perform a sequence of transitions, returning the result of each
    BinTree init should initialize a binary tree with a single element
  ․ BinTree init should initialize a binary tree with a single element
    BinTree fetch should return the value associated with a key
  ․ BinTree fetch should return the value associated with a key
    BinTree fetch should return undefined if the key is not in the tree
  ․ BinTree fetch should return undefined if the key is not in the tree
    BinTree add should add a leaf to the tree, based on key comparison
  ․ BinTree add should add a leaf to the tree, based on key comparison
    BinTree add should report a conflict and not change the state if the the key already exists
  ․ BinTree add should report a conflict and not change the state if the the key already exists
    BinTree getMin should retrieve the the minimum key, with its associated value
  ․ BinTree getMin should retrieve the the minimum key, with its associated value
    BinTree remove should remove the element with the given key and value
  ․ BinTree remove should remove the element with the given key and value
    BucketObjectStore as ObjectStore .init(ctx, className, args) should call the init() method of the relevant class with args as a parameter
  ․ BucketObjectStore as ObjectStore .init(ctx, className, args) should call the init() method of the relevant class with args as a parameter
    BucketObjectStore as ObjectStore .init(ctx, className, args) should return an ID (an object with a "$" attribute containing a string) of the newly created object
  ․ BucketObjectStore as ObjectStore .init(ctx, className, args) should return an ID (an object with a "$" attribute containing a string) of the newly created object
    BucketObjectStore as ObjectStore .trans(ctx, v1, p) should apply patch p to version v1 (v1 is a version ID), returning pair [v2, res] where v2 is the new version ID, and res is the result
  ․ BucketObjectStore as ObjectStore .trans(ctx, v1, p) should apply patch p to version v1 (v1 is a version ID), returning pair [v2, res] where v2 is the new version ID, and res is the result
    BucketObjectStore as ObjectStore .trans(ctx, v1, p) should replace the object if a _replaceWith field is added to the object
  ․ BucketObjectStore as ObjectStore .trans(ctx, v1, p) should replace the object if a _replaceWith field is added to the object
    BucketObjectStore as ObjectStore .trans(ctx, v1, p) should pass exceptions thrown by patch methods as the error field of the context
  ․ BucketObjectStore as ObjectStore .trans(ctx, v1, p) should pass exceptions thrown by patch methods as the error field of the context
    BucketObjectStore as ObjectStore .trans(ctx, v1, p) should propagate exceptions thrown by underlying invocations
  ․ BucketObjectStore as ObjectStore .trans(ctx, v1, p) should propagate exceptions thrown by underlying invocations
    BucketObjectStore as ObjectStore context should allow underlying initializations and transitions to perform initializations and transitions
  ․ BucketObjectStore as ObjectStore context should allow underlying initializations and transitions to perform initializations and transitions
    BucketObjectStore as ObjectStore context .conflict() should set the context's confclit flag to true
  ․ BucketObjectStore as ObjectStore context .conflict() should set the context's confclit flag to true
    BucketObjectStore as ObjectStore context .conflict() should propagate conflicts to calling transitions
  ․ BucketObjectStore as ObjectStore context .conflict() should propagate conflicts to calling transitions
    BucketObjectStore as ObjectStore context .effect(patch) should add a patch to the effect set held by the context
  ․ BucketObjectStore as ObjectStore context .effect(patch) should add a patch to the effect set held by the context
    BucketObjectStore .hash(bucket, obj) should return a unique ID for each given object and bucket ID
  ․ BucketObjectStore .hash(bucket, obj) should return a unique ID for each given object and bucket ID
    BucketObjectStore .hash(bucket, obj) should cache the object under its ID
  ․ BucketObjectStore .hash(bucket, obj) should cache the object under its ID
    BucketObjectStore .unhash(id) should return the object corresponding to id, if in the cache
  ․ BucketObjectStore .unhash(id) should return the object corresponding to id, if in the cache
    BucketObjectStore .unhash(id) should return the contents of an object given its ID, if in the cache
  ․ BucketObjectStore .unhash(id) should return the contents of an object given its ID, if in the cache
    BucketObjectStore .unhash(id) should put things in motion to retrieve the value of the ID, if not in the cache
  ․ BucketObjectStore .unhash(id) should put things in motion to retrieve the value of the ID, if not in the cache
    BucketObjectStore .trans(ctx, v1, p) should return v2=undefined if v1 is not in cache
  ․ BucketObjectStore .trans(ctx, v1, p) should return v2=undefined if v1 is not in cache
    BucketObjectStore .trans(ctx, v1, p) should add a field named "waitFor" to the context, containing a list of cache entries.  Waiting on them assures .trans() returns value
  ․ BucketObjectStore .trans(ctx, v1, p) should add a field named "waitFor" to the context, containing a list of cache entries.  Waiting on them assures .trans() returns value
    BucketObjectStore .trans(ctx, v1, p) should support recursive transitions
  ․ BucketObjectStore .trans(ctx, v1, p) should support recursive transitions
    BucketObjectStore .trans(ctx, v1, p) should support recursive transitions even at the event of not having items in the cache (waitFor should be filled accordingly)
  ․ BucketObjectStore .trans(ctx, v1, p) should support recursive transitions even at the event of not having items in the cache (waitFor should be filled accordingly)
    BucketObjectStore A 1000 element tree should recall any number
  ․ BucketObjectStore A 1000 element tree should recall any number
    BucketObjectStore A 1000 element tree should call make a reasonable number of calls to the bucket store
  ․ BucketObjectStore A 1000 element tree should call make a reasonable number of calls to the bucket store
    counter init should create a counter with value = 0
  ․ counter init should create a counter with value = 0
    counter add should add the given ammount to the counter value
  ․ counter add should add the given ammount to the counter value
    counter add should subtract the given amount when unapplied
  ․ counter add should subtract the given amount when unapplied
    counter get should return the counter value
  ․ counter get should return the counter value
    DummyBucketStore should accumulate all added items and replay them when fetched
  ․ DummyBucketStore should accumulate all added items and replay them when fetched
    DummyBucketStore should store each bucket individually
  ․ DummyBucketStore should store each bucket individually
    DummyBucketStore async mode should return a unique ID when adding to a bucket, such that registering to that ID guarantees the data has been saved
  ․ DummyBucketStore async mode should return a unique ID when adding to a bucket, such that registering to that ID guarantees the data has been saved
    DummyBucketStore async mode should not apply changes immediately
  ․ DummyBucketStore async mode should not apply changes immediately
    DummyObjectStore as ObjectStore .init(ctx, className, args) should call the init() method of the relevant class with args as a parameter
  ․ DummyObjectStore as ObjectStore .init(ctx, className, args) should call the init() method of the relevant class with args as a parameter
    DummyObjectStore as ObjectStore .init(ctx, className, args) should return an ID (an object with a "$" attribute containing a string) of the newly created object
  ․ DummyObjectStore as ObjectStore .init(ctx, className, args) should return an ID (an object with a "$" attribute containing a string) of the newly created object
    DummyObjectStore as ObjectStore .trans(ctx, v1, p) should apply patch p to version v1 (v1 is a version ID), returning pair [v2, res] where v2 is the new version ID, and res is the result
  ․ DummyObjectStore as ObjectStore .trans(ctx, v1, p) should apply patch p to version v1 (v1 is a version ID), returning pair [v2, res] where v2 is the new version ID, and res is the result
    DummyObjectStore as ObjectStore .trans(ctx, v1, p) should replace the object if a _replaceWith field is added to the object
  ․ DummyObjectStore as ObjectStore .trans(ctx, v1, p) should replace the object if a _replaceWith field is added to the object
    DummyObjectStore as ObjectStore .trans(ctx, v1, p) should pass exceptions thrown by patch methods as the error field of the context
  ․ DummyObjectStore as ObjectStore .trans(ctx, v1, p) should pass exceptions thrown by patch methods as the error field of the context
    DummyObjectStore as ObjectStore .trans(ctx, v1, p) should propagate exceptions thrown by underlying invocations
  ․ DummyObjectStore as ObjectStore .trans(ctx, v1, p) should propagate exceptions thrown by underlying invocations
    DummyObjectStore as ObjectStore context should allow underlying initializations and transitions to perform initializations and transitions
  ․ DummyObjectStore as ObjectStore context should allow underlying initializations and transitions to perform initializations and transitions
    DummyObjectStore as ObjectStore context .conflict() should set the context's confclit flag to true
  ․ DummyObjectStore as ObjectStore context .conflict() should set the context's confclit flag to true
    DummyObjectStore as ObjectStore context .conflict() should propagate conflicts to calling transitions
  ․ DummyObjectStore as ObjectStore context .conflict() should propagate conflicts to calling transitions
    DummyObjectStore as ObjectStore context .effect(patch) should add a patch to the effect set held by the context
  ․ DummyObjectStore as ObjectStore context .effect(patch) should add a patch to the effect set held by the context
    ObjectDisp .init(ctx, className, args) should call the init() function associated with the class
  ․ ObjectDisp .init(ctx, className, args) should call the init() function associated with the class
    ObjectDisp .init(ctx, className, args) should throw an exception if the class does not exist
  ․ ObjectDisp .init(ctx, className, args) should throw an exception if the class does not exist
    ObjectDisp .init(ctx, className, args) should pass the given context and args to the class's init() function
  ․ ObjectDisp .init(ctx, className, args) should pass the given context and args to the class's init() function
    ObjectDisp .init(ctx, className, args) should return the value of the "this" object in the context of the class's init() function
  ․ ObjectDisp .init(ctx, className, args) should return the value of the "this" object in the context of the class's init() function
    ObjectDisp .init(ctx, className, args) should add a _type field to the returned object, containing the class name
  ․ ObjectDisp .init(ctx, className, args) should add a _type field to the returned object, containing the class name
    ObjectDisp .apply(ctx, obj, patch, unapply) should call the function with name matches the _type field of the patch, in the class associated with the object.
  ․ ObjectDisp .apply(ctx, obj, patch, unapply) should call the function with name matches the _type field of the patch, in the class associated with the object.
    ObjectDisp .apply(ctx, obj, patch, unapply) should throw an exception if the patch function is not defined
  ․ ObjectDisp .apply(ctx, obj, patch, unapply) should throw an exception if the patch function is not defined
    ObjectDisp .apply(ctx, obj, patch, unapply) should pass the object as the "this" parameter to the patch function
  ․ ObjectDisp .apply(ctx, obj, patch, unapply) should pass the object as the "this" parameter to the patch function
    ObjectDisp .apply(ctx, obj, patch, unapply) should pass the context, the patch and the unapply flag as parameters to the patch function
  ․ ObjectDisp .apply(ctx, obj, patch, unapply) should pass the context, the patch and the unapply flag as parameters to the patch function
    ObjectDisp .apply(ctx, obj, patch, unapply) should return a pair [obj, res], containing the patch function's "this" object, and its return value
  ․ ObjectDisp .apply(ctx, obj, patch, unapply) should return a pair [obj, res], containing the patch function's "this" object, and its return value
    ObjectDisp .apply(ctx, obj, patch, unapply) should use patch handlers if defined (prfixed with ":")
  ․ ObjectDisp .apply(ctx, obj, patch, unapply) should use patch handlers if defined (prfixed with ":")
    ObjectDisp .apply(ctx, obj, patch, unapply) should prefer a method defined in a class over a generic patch function if both are defined
  ․ ObjectDisp .apply(ctx, obj, patch, unapply) should prefer a method defined in a class over a generic patch function if both are defined
    Scheduler allows users to register a callback to a condition. Once the condition is met, the callback is called
  ․ Scheduler allows users to register a callback to a condition. Once the condition is met, the callback is called
    Scheduler should not call a callback unless the condition has been met
  ․ Scheduler should not call a callback unless the condition has been met
    Scheduler should allow multiple registrations on the same condition
  ․ Scheduler should allow multiple registrations on the same condition
    Scheduler should call each callback only once even if notified multiple times
  ․ Scheduler should call each callback only once even if notified multiple times
    Scheduler should call a callback only when all conditions are met
  ․ Scheduler should call a callback only when all conditions are met
    SimpleCache .store(id, obj[, json]) should store an object in the cache under the given ID
  ․ SimpleCache .store(id, obj[, json]) should store an object in the cache under the given ID
    SimpleCache .store(id, obj[, json]) should retrieve the same instance on a first fetch
  ․ SimpleCache .store(id, obj[, json]) should retrieve the same instance on a first fetch
    SimpleCache .store(id, obj[, json]) should retrieve the same object once and again, even if it was modified on the outside
  ․ SimpleCache .store(id, obj[, json]) should retrieve the same object once and again, even if it was modified on the outside
    SimpleCache .store(id, obj[, json]) should use the json argument, if supplied, as the JSON representation of the object to be used when the instance is no longer available
  ․ SimpleCache .store(id, obj[, json]) should use the json argument, if supplied, as the JSON representation of the object to be used when the instance is no longer available
    SimpleCache .abolish() should remove all elements from the cache
  ․ SimpleCache .abolish() should remove all elements from the cache
    SimpleCache .waitFor(keys, callback) should call the given callback once all keys are in the cache
  ․ SimpleCache .waitFor(keys, callback) should call the given callback once all keys are in the cache
    SimpleCache .waitFor(keys, callback) should throw an exception if one of the keys is already in the cache
  ․ SimpleCache .waitFor(keys, callback) should throw an exception if one of the keys is already in the cache
    SimpleCache .check(key) should return true if key exists in the cache
  ․ SimpleCache .check(key) should return true if key exists in the cache
    vercast .hash(obj) should return a SHA-256 digest of the given string
  ․ vercast .hash(obj) should return a SHA-256 digest of the given string
    vercast .genID(bucketID, hash) should create a version ID based on a bucket ID (string) and a hash (string)
  ․ vercast .genID(bucketID, hash) should create a version ID based on a bucket ID (string) and a hash (string)
    vercast .bucketID(id) should return the bucket ID associated with the given version ID
  ․ vercast .bucketID(id) should return the bucket ID associated with the given version ID
    vercast .objID(id) should return the object hash part of the given version ID
  ․ vercast .objID(id) should return the object hash part of the given version ID
    vercast .childObjects(obj) should return a list of sub-object IDs nested in obj
  ․ vercast .childObjects(obj) should return a list of sub-object IDs nested in obj
    vercast .childObjects(obj) should recursively search for children in nested objects and arrays
  ․ vercast .childObjects(obj) should recursively search for children in nested objects and arrays
    vercast .randomByKey(key, prob) should return true in probability prob
  ․ vercast .randomByKey(key, prob) should return true in probability prob
    vercast .randomByKey(key, prob) should behave consistently given a constant sequence of keys
  ․ vercast .randomByKey(key, prob) should behave consistently given a constant sequence of keys

  90 passing (5s)

