
[90m    application initialState should properly create an initial state
[32m  â€¤[0m[90m application initialState should properly create an initial state
[90m    application apply should return the query result based on the state
[32m  â€¤[0m[90m application apply should return the query result based on the state
[90m    application apply should apply the patch to the state
[32m  â€¤[0m[90m application apply should apply the patch to the state
[90m    application inv should invert patches
[32m  â€¤[0m[90m application inv should invert patches
[90m    AppBase .trans(branch, patch, options, cb(err)) should apply the given patch on the tip of the given branch
[32m  â€¤[0m[90m AppBase .trans(branch, patch, options, cb(err)) should apply the given patch on the tip of the given branch
[90m    AppBase .trans(branch, patch, options, cb(err)) should report conflicts
[32m  â€¤[0m[90m AppBase .trans(branch, patch, options, cb(err)) should report conflicts
[90m    AppBase .trans(branch, patch, options, cb(err)) should force the change if the strong option is used
[32m  â€¤[0m[90m AppBase .trans(branch, patch, options, cb(err)) should force the change if the strong option is used
[90m    AppBase .trans(branch, patch, options, cb(err)) should apply effect patches as part of the transition
[32m  â€¤[0m[90m AppBase .trans(branch, patch, options, cb(err)) should apply effect patches as part of the transition
[90m    AppBase .merge(dest, source, options, cb(err)) should apply the patches contributing to source to the tip of branch
[32m  â€¤[0m[90m AppBase .merge(dest, source, options, cb(err)) should apply the patches contributing to source to the tip of branch
[90m    AppBase .merge(dest, source, options, cb(err)) should report conflicts if they occur
[32m  â€¤[0m[90m AppBase .merge(dest, source, options, cb(err)) should report conflicts if they occur
[90m    AppBase .merge(dest, source, options, cb(err)) should accept a "weak" option, by which it would apply only non-conflicting changes
[32m  â€¤[0m[90m AppBase .merge(dest, source, options, cb(err)) should accept a "weak" option, by which it would apply only non-conflicting changes
[90m    AppBase .merge(dest, source, options, cb(err)) should apply a back-merge correctly
[32m  â€¤[0m[90m AppBase .merge(dest, source, options, cb(err)) should apply a back-merge correctly
[90m    atom get should return the atom's value
[32m  â€¤[0m[90m atom get should return the atom's value
[90m    atom get should return the last set value even at the event of a conflict
[32m  â€¤[0m[90m atom get should return the last set value even at the event of a conflict
[90m    atom set should change the state to contain the "to" value, given that the "from" value matches the current state
[32m  â€¤[0m[90m atom set should change the state to contain the "to" value, given that the "from" value matches the current state
[90m    atom set should report a conflict if the "from" value does not match
[32m  â€¤[0m[90m atom set should report a conflict if the "from" value does not match
[90m    atom set should invert patches correctly
[32m  â€¤[0m[90m atom set should invert patches correctly
[90m    atom get_all should return all possible values
[32m  â€¤[0m[90m atom get_all should return all possible values
[90m    BranchBase .newBranch(branchName, s0, cb(err)) should create a new branch with the given branchName, with the initial state s0
[32m  â€¤[0m[90m BranchBase .newBranch(branchName, s0, cb(err)) should create a new branch with the given branchName, with the initial state s0
[90m    BranchBase .init(branchName, evaluator, args, cb(err)) should create a new branch with the given evaluator and arguments
[32m  â€¤[0m[90m BranchBase .init(branchName, evaluator, args, cb(err)) should create a new branch with the given evaluator and arguments
[90m    BranchBase .trans(branch, patch, options, cb(err)) should apply the given patch on the tip of the given branch
[32m  â€¤[0m[90m BranchBase .trans(branch, patch, options, cb(err)) should apply the given patch on the tip of the given branch
[90m    BranchBase .trans(branch, patch, options, cb(err)) should retry and reapply the patch over the new tip if the tip moves during the transition
[32m  â€¤[0m[90m BranchBase .trans(branch, patch, options, cb(err)) should retry and reapply the patch over the new tip if the tip moves during the transition
[90m    BranchBase .trans(branch, patch, options, cb(err)) should retry the given number of times
[32m  â€¤[0m[90m BranchBase .trans(branch, patch, options, cb(err)) should retry the given number of times
[90m    BranchBase .trans(branch, patch, options, cb(err)) should emit an error by default if the patch conflicts
[32m  â€¤[0m[90m BranchBase .trans(branch, patch, options, cb(err)) should emit an error by default if the patch conflicts
[90m    BranchBase .trans(branch, patch, options, cb(err)) should force the change if the strong option is used
[32m  â€¤[0m[90m BranchBase .trans(branch, patch, options, cb(err)) should force the change if the strong option is used
[90m    BranchBase .trans(branch, patch, options, cb(err)) should apply effect patches as part of the transition
[32m  â€¤[0m[90m BranchBase .trans(branch, patch, options, cb(err)) should apply effect patches as part of the transition
[90m    BranchBase .merge(dest, source, options, cb(err)) should apply the patches contributing to source to the tip of branch
[32m  â€¤[0m[90m BranchBase .merge(dest, source, options, cb(err)) should apply the patches contributing to source to the tip of branch
[90m    BranchBase .merge(dest, source, options, cb(err)) should emit an error by default if a merge conflict is found
[32m  â€¤[0m[90m BranchBase .merge(dest, source, options, cb(err)) should emit an error by default if a merge conflict is found
[90m    BranchBase .merge(dest, source, options, cb(err)) should accept a "weak" option, by which it would apply only non-conflicting changes
[32m  â€¤[0m[90m BranchBase .merge(dest, source, options, cb(err)) should accept a "weak" option, by which it would apply only non-conflicting changes
[90m    BranchBase .merge(dest, source, options, cb(err)) should accept a "strong" option, by which it will force the change in case of a conflict
[32m  â€¤[0m[90m BranchBase .merge(dest, source, options, cb(err)) should accept a "strong" option, by which it will force the change in case of a conflict
[90m    BranchBase .merge(dest, source, options, cb(err)) should apply a back-merge correctly
[32m  â€¤[0m[90m BranchBase .merge(dest, source, options, cb(err)) should apply a back-merge correctly
[90m    collection init should create an empty collection
[32m  â€¤[0m[90m collection init should create an empty collection
[90m    collection add should add a key/value pair to the collection
[32m  â€¤[0m[90m collection add should add a key/value pair to the collection
[90m    composite patch apply should apply the given patches one by one
[32m  â€¤[0m[90m composite patch apply should apply the given patches one by one
[90m    composite patch apply should return an array of the underlying results
[32m  â€¤[0m[90m composite patch apply should return an array of the underlying results
[90m    composite patch apply should return no result if none of the underlying patches return result
[32m  â€¤[0m[90m composite patch apply should return no result if none of the underlying patches return result
[90m    composite patch apply weak should not apply conflicting patches
[32m  â€¤[0m[90m composite patch apply weak should not apply conflicting patches
[90m    composite patch apply weak should report the conflicting patch in the results
[32m  â€¤[0m[90m composite patch apply weak should report the conflicting patch in the results
[90m    composite patch apply weak should provide $badPatch in nested patches
[32m  â€¤[0m[90m composite patch apply weak should provide $badPatch in nested patches
[90m    composite patch unapply should unapply the given patches in reverse order
[32m  â€¤[0m[90m composite patch unapply should unapply the given patches in reverse order
[90m    counter get should initially return 0
[32m  â€¤[0m[90m counter get should initially return 0
[90m    counter add should increase the counter value by the given amount
[32m  â€¤[0m[90m counter add should increase the counter value by the given amount
[90m    counter add should be reversible
[32m  â€¤[0m[90m counter add should be reversible
[90m    directory should propagate any patches it does not handle itself to child objects
[32m  â€¤[0m[90m directory should propagate any patches it does not handle itself to child objects
[90m    directory should propagate unapplied patches as well as applied
[32m  â€¤[0m[90m directory should propagate unapplied patches as well as applied
[90m    directory create should create a child node using the given evaluator type and arguments
[32m  â€¤[0m[90m directory create should create a child node using the given evaluator type and arguments
[90m    directory create should delete a child when unapplied
[32m  â€¤[0m[90m directory create should delete a child when unapplied
[90m    directory create should report a conflict when unpatched if the child state does not match the construction parameters
[32m  â€¤[0m[90m directory create should report a conflict when unpatched if the child state does not match the construction parameters
[90m    directory delete should remove the object at the given path from the directory
[32m  â€¤[0m[90m directory delete should remove the object at the given path from the directory
[90m    directory delete should report a conflic if the removed child state does not match the given hash
[32m  â€¤[0m[90m directory delete should report a conflic if the removed child state does not match the given hash
[90m    directory delete should re-create a child if unapplied
[32m  â€¤[0m[90m directory delete should re-create a child if unapplied
[90m    directory delete should conflict when unapplied if the child already exists
[32m  â€¤[0m[90m directory delete should conflict when unapplied if the child already exists
[90m    directory get_hash should return the hash of the child at the given path
[32m  â€¤[0m[90m directory get_hash should return the hash of the child at the given path
[90m    directory add_mapping should add a mapping to a child, so that every patch applied to that child is also applied to the mapper
[32m  â€¤[0m[90m directory add_mapping should add a mapping to a child, so that every patch applied to that child is also applied to the mapper
[90m    directory add_mapping should remove a mapping to a child, when unapplied
[32m  â€¤[0m[90m directory add_mapping should remove a mapping to a child, when unapplied
[90m    DummyAtomicKVS as AtomicKeyValue .newKey(key, val, cb(err)) should store a new key/value pair, given that key does not already exist
[32m  â€¤[0m[90m DummyAtomicKVS as AtomicKeyValue .newKey(key, val, cb(err)) should store a new key/value pair, given that key does not already exist
[90m    DummyAtomicKVS as AtomicKeyValue .newKey(key, val, cb(err)) should emit an error when the key already exists
[32m  â€¤[0m[90m DummyAtomicKVS as AtomicKeyValue .newKey(key, val, cb(err)) should emit an error when the key already exists
[90m    DummyAtomicKVS as AtomicKeyValue .retrieve(key, cb(err, val)) should emit an error if the value does not exist
[32m  â€¤[0m[90m DummyAtomicKVS as AtomicKeyValue .retrieve(key, cb(err, val)) should emit an error if the value does not exist
[90m    DummyAtomicKVS as AtomicKeyValue .modify(key, oldVal, newVal, cb(err, valAfterMod)) should change the value under key to newVal, given that the previous value was oldVal
[32m  â€¤[0m[90m DummyAtomicKVS as AtomicKeyValue .modify(key, oldVal, newVal, cb(err, valAfterMod)) should change the value under key to newVal, given that the previous value was oldVal
[90m    DummyAtomicKVS as AtomicKeyValue .modify(key, oldVal, newVal, cb(err, valAfterMod)) should not change the value under key if the current value does not equal oldVal
[32m  â€¤[0m[90m DummyAtomicKVS as AtomicKeyValue .modify(key, oldVal, newVal, cb(err, valAfterMod)) should not change the value under key if the current value does not equal oldVal
[90m    DummyBranch as Branch checkedUpdate should update the branch state if given that the state condition is met
[32m  â€¤[0m[90m DummyBranch as Branch checkedUpdate should update the branch state if given that the state condition is met
[90m    DummyBranch as Branch checkedUpdate should return the tip state before modification
[32m  â€¤[0m[90m DummyBranch as Branch checkedUpdate should return the tip state before modification
[90m    DummyBranch as Branch checkedUpdate should not update the branch state if the first argument does not match the current tip value
[32m  â€¤[0m[90m DummyBranch as Branch checkedUpdate should not update the branch state if the first argument does not match the current tip value
[90m    DummyVersionGraph as VersionGraph addEdge should accept an edge and add it to the graph
[32m  â€¤[0m[90m DummyVersionGraph as VersionGraph addEdge should accept an edge and add it to the graph
[90m    DummyVersionGraph as VersionGraph addEdge should create a dual mapping, mapping also the destination to the source
[32m  â€¤[0m[90m DummyVersionGraph as VersionGraph addEdge should create a dual mapping, mapping also the destination to the source
[90m    DummyVersionGraph as VersionGraph findCommonAncestor should find the common ancestor of two nodes, and the path to each of them
[32m  â€¤[0m[90m DummyVersionGraph as VersionGraph findCommonAncestor should find the common ancestor of two nodes, and the path to each of them
[90m    DummyVersionGraph as VersionGraph findCommonAncestor should handle the case where there are also common descendants
[32m  â€¤[0m[90m DummyVersionGraph as VersionGraph findCommonAncestor should handle the case where there are also common descendants
[90m    DummyVersionGraph as VersionGraph findCommonAncestor should return the path from the common ancestor to both nodes
[32m  â€¤[0m[90m DummyVersionGraph as VersionGraph findCommonAncestor should return the path from the common ancestor to both nodes
[90m    EvalEnv init(evaluator, args, cb(err, h0)) should return a hash to an object constructed by the evaluator's init() method
[32m  â€¤[0m[90m EvalEnv init(evaluator, args, cb(err, h0)) should return a hash to an object constructed by the evaluator's init() method
[90m    EvalEnv init(evaluator, args, cb(err, h0)) should pass the evaluator as the "this" of the called method
[32m  â€¤[0m[90m EvalEnv init(evaluator, args, cb(err, h0)) should pass the evaluator as the "this" of the called method
[90m    EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should apply patch to s1 by invoking the evaluator's apply method, to retrieve s2 and res
[32m  â€¤[0m[90m EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should apply patch to s1 by invoking the evaluator's apply method, to retrieve s2 and res
[90m    EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should use the patch evaluator if one exists for the patch type
[32m  â€¤[0m[90m EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should use the patch evaluator if one exists for the patch type
[90m    EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should pass the evaluator as the "this" of the called method
[32m  â€¤[0m[90m EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should pass the evaluator as the "this" of the called method
[90m    EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should report a conflict if a propagated patch conflicted
[32m  â€¤[0m[90m EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should report a conflict if a propagated patch conflicted
[90m    EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should collect effect patches from the application of the given patch
[32m  â€¤[0m[90m EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should collect effect patches from the application of the given patch
[90m    EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should accumulate effects of underlying patches
[32m  â€¤[0m[90m EvalEnv apply(s1, patch, unapply, cb(err, s2, res, eff, conf)) should accumulate effects of underlying patches
[90m    EvalEnv trans(h1, patch, cb(err, h2, res, eff, conf)) should apply the patch
[32m  â€¤[0m[90m EvalEnv trans(h1, patch, cb(err, h2, res, eff, conf)) should apply the patch
[90m    EvalEnv trans(h1, patch, cb(err, h2, res, eff, conf)) should avoid repeating calculations already done
[32m  â€¤[0m[90m EvalEnv trans(h1, patch, cb(err, h2, res, eff, conf)) should avoid repeating calculations already done
[90m    EvalEnv query(s, q, cb(err, res)) should apply query patch q to object with state s, emitting res
[32m  â€¤[0m[90m EvalEnv query(s, q, cb(err, res)) should apply query patch q to object with state s, emitting res
[90m    EvalEnv query(s, q, cb(err, res)) should emit an error if the query changes the state
[32m  â€¤[0m[90m EvalEnv query(s, q, cb(err, res)) should emit an error if the query changes the state
[90m    EvalEnv query(s, q, cb(err, res)) should do the opposite of applying patch to s1. Applying patch to s2 should result in s1, given that conf is false
[32m  â€¤[0m[90m EvalEnv query(s, q, cb(err, res)) should do the opposite of applying patch to s1. Applying patch to s2 should result in s1, given that conf is false
[90m    EvalEnv query(s, q, cb(err, res)) should use the unpatch evaluator if one exists for the patch type
[32m  â€¤[0m[90m EvalEnv query(s, q, cb(err, res)) should use the unpatch evaluator if one exists for the patch type
[90m    HashDB should store its own copy of the object
[32m  â€¤[0m[90m HashDB should store its own copy of the object
[90m    HashDB hash(obj, cb(err, hash)) should give any two different JSONable objects a different hash code
[32m  â€¤[0m[90m HashDB hash(obj, cb(err, hash)) should give any two different JSONable objects a different hash code
[90m    HashDB hash(obj, cb(err, hash)) should act as an identity function when given a hash as input
[32m  â€¤[0m[90m HashDB hash(obj, cb(err, hash)) should act as an identity function when given a hash as input
[90m    HashDB unhash(hash, cb(err, obj)) should reconstruct an object from the hash that is identical to the origianl object
[32m  â€¤[0m[90m HashDB unhash(hash, cb(err, obj)) should reconstruct an object from the hash that is identical to the origianl object
[90m    HashDB unhash(hash, cb(err, obj)) should act as an identity when given a non-hash object as input
[32m  â€¤[0m[90m HashDB unhash(hash, cb(err, obj)) should act as an identity when given a non-hash object as input
[90m    HashedApp initialState should return the initial state's hash
[32m  â€¤[0m[90m HashedApp initialState should return the initial state's hash
[90m    HashedApp apply should calculate the hash of the new state, the computation result and the safety flag, based on an original state and a patch
[32m  â€¤[0m[90m HashedApp apply should calculate the hash of the new state, the computation result and the safety flag, based on an original state and a patch
[90m    HashedApp apply _inv should handle _inv patches
[32m  â€¤[0m[90m HashedApp apply _inv should handle _inv patches
[90m    HashedApp apply _inv should support _inv of _inv patches
[32m  â€¤[0m[90m HashedApp apply _inv should support _inv of _inv patches
[90m    HashedApp apply _comp should handle _comp patches
[32m  â€¤[0m[90m HashedApp apply _comp should handle _comp patches
[90m    HashedApp apply _comp should support _inv of _comp patches
[32m  â€¤[0m[90m HashedApp apply _comp should support _inv of _comp patches
[90m    HashedApp apply _comp should replace the output from patches that were not safely applied with an object containing a $badPatch field, containing the patch
[32m  â€¤[0m[90m HashedApp apply _comp should replace the output from patches that were not safely applied with an object containing a $badPatch field, containing the patch
[90m    HashedApp apply _comp should support a "weak" flag, which when exists and true, avoids execution of unsafe sub-patches
[32m  â€¤[0m[90m HashedApp apply _comp should support a "weak" flag, which when exists and true, avoids execution of unsafe sub-patches
[90m    HashedApp apply _hashed should handle _hashed patches
[32m  â€¤[0m[90m HashedApp apply _hashed should handle _hashed patches
[90m    HashedApp apply _hashed should support _inv of _hashed
[32m  â€¤[0m[90m HashedApp apply _hashed should support _inv of _hashed
[90m    HashedApp trans should return the hash of the target state when given a source state and a patch
[32m  â€¤[0m[90m HashedApp trans should return the hash of the target state when given a source state and a patch
[90m    HashedApp trans should cache previous calls and only invoke the actual method if the combination of input state and patch have not yet been encountered
[32m  â€¤[0m[90m HashedApp trans should cache previous calls and only invoke the actual method if the combination of input state and patch have not yet been encountered
[90m    HashedApp trans should avoid hashing _hashed patches, and should used the undelying hash instead
[32m  â€¤[0m[90m HashedApp trans should avoid hashing _hashed patches, and should used the undelying hash instead
[90m    HashedApp query should return the result of applying a patch
[32m  â€¤[0m[90m HashedApp query should return the result of applying a patch
[90m    HashedApp query should fail when given a patch that modifies the state
[32m  â€¤[0m[90m HashedApp query should fail when given a patch that modifies the state
[90m    HashedApp branchQuery should perform a query on the tip of the given branch
[32m  â€¤[0m[90m HashedApp branchQuery should perform a query on the tip of the given branch
[90m    HashedApp branchTrans should perform a transition, updating the tip of the branch
[32m  â€¤[0m[90m HashedApp branchTrans should perform a transition, updating the tip of the branch
[90m    inverse patch patch should unapply the underlying patch
[32m  â€¤[0m[90m inverse patch patch should unapply the underlying patch
[90m    inverse patch unpatch should apply the undelying patch
[32m  â€¤[0m[90m inverse patch unpatch should apply the undelying patch
[90m    jsMapper init should take the args as state
[32m  â€¤[0m[90m jsMapper init should take the args as state
[90m    jsMapper map should invoke the map() function defined in the state, with the patch as parameter when applied
[32m  â€¤[0m[90m jsMapper map should invoke the map() function defined in the state, with the patch as parameter when applied
[90m    jsMapper map should pass the state as the map function's "this" argument
[32m  â€¤[0m[90m jsMapper map should pass the state as the map function's "this" argument
[90m    jsMapper map should interpret invocations of the "emit" function as effect
[32m  â€¤[0m[90m jsMapper map should interpret invocations of the "emit" function as effect
[90m    jsMapper map should invoke unmap() when unapplied
[32m  â€¤[0m[90m jsMapper map should invoke unmap() when unapplied
[90m    jsMapper map should call a method named map_foo() for patch where _type="foo", if such a method exists
[32m  â€¤[0m[90m jsMapper map should call a method named map_foo() for patch where _type="foo", if such a method exists
[90m    logicBase query should provide a matching statement, if one exists
[32m  â€¤[0m[90m logicBase query should provide a matching statement, if one exists
[90m    logicBase Implementation init should create a node of the given depth with no value and no children
[32m  â€¤[0m[90m logicBase Implementation init should create a node of the given depth with no value and no children
[90m    logicBase Implementation init should set depth to zero if not given
[32m  â€¤[0m[90m logicBase Implementation init should set depth to zero if not given
[90m    logicBase Implementation update assert should add a value to a value-less/child-less node
[32m  â€¤[0m[90m logicBase Implementation update assert should add a value to a value-less/child-less node
[90m    logicBase Implementation update assert should create a child if a an assertion is made when a value is already given
[32m  â€¤[0m[90m logicBase Implementation update assert should create a child if a an assertion is made when a value is already given
[90m    logicBase Implementation update assert should index compound terms in the form name/arity
[32m  â€¤[0m[90m logicBase Implementation update assert should index compound terms in the form name/arity
[90m    logicBase Implementation update assert should place two children under a common child if they share the same top-level
[32m  â€¤[0m[90m logicBase Implementation update assert should place two children under a common child if they share the same top-level
[90m    logicBase Implementation update assert should allow any number (not limited to 2) of children to a node
[32m  â€¤[0m[90m logicBase Implementation update assert should allow any number (not limited to 2) of children to a node
[90m    util seq(funcs, done) should return a function that runs asynchronous functions in funcs in order
[32m  â€¤[0m[90m util seq(funcs, done) should return a function that runs asynchronous functions in funcs in order
[90m    util seq(funcs, done) should handle errors by calling done with the error
[32m  â€¤[0m[90m util seq(funcs, done) should handle errors by calling done with the error
[90m    util seq(funcs, done) should handle exceptions thrown by functions by calling done with the exception
[32m  â€¤[0m[90m util seq(funcs, done) should handle exceptions thrown by functions by calling done with the exception
[90m    util seq(funcs, done) should call done with no error if all is successful
[32m  â€¤[0m[90m util seq(funcs, done) should call done with no error if all is successful
[90m    util seq(funcs, done) _.to(names...) should return a function that places the corresponding arguments in "this" (skipping err)
[32m  â€¤[0m[90m util seq(funcs, done) _.to(names...) should return a function that places the corresponding arguments in "this" (skipping err)
[90m    util timeUid() should return a unique string
[32m  â€¤[0m[90m util timeUid() should return a unique string
[90m    util timeUid() should return a larger value when called over one millisecond later
[32m  â€¤[0m[90m util timeUid() should return a larger value when called over one millisecond later
[90m    util Encoder(allowedSpecial) .encode(str) should encode str in a way that will only include letters, digits or characters from allowedSpecial
[32m  â€¤[0m[90m util Encoder(allowedSpecial) .encode(str) should encode str in a way that will only include letters, digits or characters from allowedSpecial
[90m    util Encoder(allowedSpecial) .encode(str) should throw an exception if less than three special characters are allowed
[32m  â€¤[0m[90m util Encoder(allowedSpecial) .encode(str) should throw an exception if less than three special characters are allowed
[90m    util Encoder(allowedSpecial) .decode(enc) should decode a string encoded with .encode()
[32m  â€¤[0m[90m util Encoder(allowedSpecial) .decode(enc) should decode a string encoded with .encode()
[90m    util parallel(n, callback) should return a callback function that will call "callback" after it has been called n times
[32m  â€¤[0m[90m util parallel(n, callback) should return a callback function that will call "callback" after it has been called n times
[90m    util parallel(n, callback) should call the callback immediately with an error if an error is given to the parallel callback
[32m  â€¤[0m[90m util parallel(n, callback) should call the callback immediately with an error if an error is given to the parallel callback
[90m    util Worker should call a given function iteratively, in given intervals, until stopped
[32m  â€¤[0m[90m util Worker should call a given function iteratively, in given intervals, until stopped
[90m    util Worker should assure that no more than a given number of instances of the function are running at any given time
[32m  â€¤[0m[90m util Worker should assure that no more than a given number of instances of the function are running at any given time
[90m    util repeat should repeat the given loop a given number of times, sending the iteration number to each invocation
[32m  â€¤[0m[90m util repeat should repeat the given loop a given number of times, sending the iteration number to each invocation
[90m    util depend should execute the given callback functions in the order of their dependencies
[32m  â€¤[0m[90m util depend should execute the given callback functions in the order of their dependencies
[90m    util depend should only call the callback once in the face of an exception
[32m  â€¤[0m[90m util depend should only call the callback once in the face of an exception
[90m    VCObj createObject(cls, s0, cb(err, h0)) should create an object state hash for the given class and initial state
[32m  â€¤[0m[90m VCObj createObject(cls, s0, cb(err, h0)) should create an object state hash for the given class and initial state
[90m    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should apply a patch to the given state, activating a class method
[32m  â€¤[0m[90m VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should apply a patch to the given state, activating a class method
[90m    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should emit the new state hash, and the result emitted by the invoked method
[32m  â€¤[0m[90m VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should emit the new state hash, and the result emitted by the invoked method
[90m    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should pass the invoked method the state as its this parameter
[32m  â€¤[0m[90m VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should pass the invoked method the state as its this parameter
[90m    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should emit the new state based on the content of "this" when the method returns
[32m  â€¤[0m[90m VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should emit the new state based on the content of "this" when the method returns
[90m    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should allow objects to further call other objects by sending them patches
[32m  â€¤[0m[90m VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should allow objects to further call other objects by sending them patches
[90m    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should report conflict if the context conflict() method was called
[32m  â€¤[0m[90m VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should report conflict if the context conflict() method was called
[90m    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should propagate conflicts reported in child objects
[32m  â€¤[0m[90m VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should propagate conflicts reported in child objects
[90m    VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should accept patches that have a "code" field instead of "type"
[32m  â€¤[0m[90m VCObj apply(h1, patch, cb(err, h2, res, effect, conflict)) should accept patches that have a "code" field instead of "type"
[90m    VCObj invert(patch, cb(err, invPatch)) should invert any patch that has an inv field specifying its inversion logic
[32m  â€¤[0m[90m VCObj invert(patch, cb(err, invPatch)) should invert any patch that has an inv field specifying its inversion logic
[90m    VCObj invert(patch, cb(err, invPatch)) should return the patch unchanged in case an inv field does not exist
[32m  â€¤[0m[90m VCObj invert(patch, cb(err, invPatch)) should return the patch unchanged in case an inv field does not exist
[90m    VCObj createChainPatch(patches, cb(err, patch)) should create a patch that applies all given patches one by one
[32m  â€¤[0m[90m VCObj createChainPatch(patches, cb(err, patch)) should create a patch that applies all given patches one by one
[90m    VCObj createChainPatch(patches, cb(err, patch)) should support correct inversion of the resulting patch
[32m  â€¤[0m[90m VCObj createChainPatch(patches, cb(err, patch)) should support correct inversion of the resulting patch
[90m    VCObj trans(h1, patch, cb(h2, res, effect, conflict)) should apply the given patch on h1 to receive h2
[32m  â€¤[0m[90m VCObj trans(h1, patch, cb(h2, res, effect, conflict)) should apply the given patch on h1 to receive h2
[90m    VCObj trans(h1, patch, cb(h2, res, effect, conflict)) should cache previous state/patch pairs and avoid re-calculation
[32m  â€¤[0m[90m VCObj trans(h1, patch, cb(h2, res, effect, conflict)) should cache previous state/patch pairs and avoid re-calculation
[90m    VCObj query(h1, patch, cb(err, ret)) should return the result of applying the patch on an object with the given state
[32m  â€¤[0m[90m VCObj query(h1, patch, cb(err, ret)) should return the result of applying the patch on an object with the given state
[90m    VCObj query(h1, patch, cb(err, ret)) should fail if the patch modifies the state
[32m  â€¤[0m[90m VCObj query(h1, patch, cb(err, ret)) should fail if the patch modifies the state

[92m [0m[32m 154 passing[0m[90m (1s)[0m

